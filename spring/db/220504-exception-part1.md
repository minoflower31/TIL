# 예외 계층

<img width="397" alt="image" src="https://user-images.githubusercontent.com/56334513/166666681-a42bac21-64b0-41f6-9a43-5fe77bbdac45.png">

#### Exception
+ 체크 예외
+ Exception과 그 하위의 예외는 모두 컴파일러가 체크하는 예외. 단, RuntimeException만 예외

#### RuntimeException

- 런타임 예외 or 언체크 예외
- RuntimeException과 그 하위의 예외는 모두 언체크 예외

<br>

### 예외의 2가지 규칙

1. 예외는 잡아서 던지거나, 처리해야 한다.
2. 지정한 예외뿐만 아니라 그 예외의 자식까지도 함께 처리된다.

<br>
c.f. 웹 애플리케이션에서 예외를 처리하지 않고 계속 던지는 경우는?
+ WAS가 해당 예외를 받아서 처리. 주로 개발자가 지정한 오류 페이지를 사용자에게 보여줌

<br>

### 체크 예외의 장단점

체크 예외는 예외를 잡아서 처리할 수 없다면 밖으로 던져야만 한다.(생략 시, 컴파일 오류 발생. 무조건 던져!)
- 장점: 개발자가 실수로 예외를 누락하지 않게 함
- 단점: 예외가 많을수록 번거롭고 세세한 예외까지 작성해야 함. 또한 의존 관계에서 문제 발생

<br>

### 언체크 예외의 장단점

언체크 예외는 예외를 던질 때 throws를 생략 가능하게 한다. (생략 시, 자동으로 던져짐. 던질까 말까) <br>
하지만 중요한 예외라면 throws를 명시적으로 나타내 개발자가 코드를 보고 예외를 확인할 수 있다.
- 장점: 신경쓰고 싶지 않은 언체크 예외 무시 가능
- 단점: 개발자가 실수로 예외를 누락할 수 있음

#### 결국 예외를 던질 때 `throws`를 사용하는지 안하는지의 차이다.

<br>

## 활용

**기본 원칙**
1. 기본적으로 언체크(런타임) 예외를 사용 (트렌드)
2. 체크 예외는 비즈니스 로직 상 의도적으로 던지는 예외에만!
   - e.g. 계좌 이체 실패 등
   - 하지만 100%는 아님. 정말 심각할 때만

### 체크 예외의 문제점

> Repository -> Service -> Controller -> 예외 공통 처리(서블릿 오류 page, ControllerAdvice)

Repository에서 SQLException 예외를 던져버린다면?
+ Service, Controller 또한 SQLException을 던질 수 밖에 없음(자신들이 처리할 수 없기 때문)
  + 결국 Service와 Controller는 SQLException을 의존하게 되고, JPAException으로 변경되면 싹 다 고쳐야 한다. (OCP, DIP 위배) 
+ 이러한 해결 불가능한 공통 예외는 로그를 남기고, 개발자가 빨리 인지해야 한다.
  + **언체크 예외도 마찬가지. 하지만 throws를 생략할 수 있다는 장점!** 
  + 해결방법: 서블릿 필터, 스프링 인터셉터, ControllerAdvice 사용


### 최근 라이브러리들은 어떤 예외를 쓸까

대부분 런타임 예외를 기본으로 제공. JPA뿐만 아니라 스프링도 런타임 예외를 대부분 제공. <br>
단, 런타임 예외는 놓칠 가능성이 있으므로 문서화가 중요함
- 주석으로 설명
- `throws 런타임예외`를 메서드에 달아서 인지하도록 함

<br>

## 예외 포함과 스택 트레이스

#### 예외를 전환하려면 꼭 기존 예외를 포함해야 한다. 그렇지 않으면 스택 트레이스에서 누락될 수 있다.

- 실무에서는 꼭 log로 남기기(e.printStackTrace 사용X)

```java
try {
    //code
} catch(SQLException e) {
    throw new RuntimeSQLException(e); //기존 예외를 포함시킴
}
```
- 만약 예외를 포함하지 않았다면 DB에 연동했을 때 DB에서 일어나는 예외를 확인할 수 없게 되버린다.

<br>
<br>

참고: 인프런 "스프링 DB 1편 - 데이터 접근 핵심 원리" https://inf.run/D8N6