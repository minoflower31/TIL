# Heap

#### 최댓값과 최솟값을 보다 빠르게 찾아내기 위해 고안된 완전 이진 트리

- 완전 이진 트리란?
   - 노드를 삽입할 때 최하단 왼쪽 노드부터 채워넣는 트리

![image](https://user-images.githubusercontent.com/56334513/163342169-70bf5b0a-59be-40c1-b5d8-56be7946cb16.png)
출처: https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)
<br>

### 힙을 사용하는 이유

배열에서 최댓값과 최솟값을 찾으려면 O(N)의 시간이 걸리지만, 힙은 O(logN)이 걸리기 때문.

<br>

## 특징

- 최대 힙과 최소 힙으로 분류 (PriorityQueue는 최소 힙 기준)
- 노드의 값은 자식 노드가 가진 값보다 크거나 같음
- **완전 이진 트리** 형태

<br>
<br>

## 힙과 이진 탐색 트리 비교

#### 공통점

힙과 이진 탐색 트리는 모두 **이진 트리 구조** <br>
<br>

#### 차이점

- **힙**은 노드의 값이 자식 노드가 가진 값보다 크거나 같아야 함(최대 힙 기준)
- **이진 탐색 트리**는 부모 노드 기준으로 왼쪽 노드에는 작은 값, 오른쪽 노드에는 큰 값

<br>
<br>

## 동작 방식

### 1. 데이터 insert

- 삽입된 데이터는 최하단부 왼쪽 노드부터 채워짐
- 만약 부모 노드보다 값이 크다면, `swap`
<br>

### 2. 데이터 pop

1. root 노드를 변수에 할당해둠 
2. 마지막으로 삽입한 노드와 root 노드 위치 swap. 마지막 노드 위치에 root 노드의 데이터가 있으므로 remove.
3. 이 때 root 노드 값이 child 노드보다 작을 경우 아래로 이동
   - child 노드보다 크거나 같을 때까지 반복
   - 경우의 수를 나눈다.
      1. 자식이 아예 없을 경우
      2. 왼쪽 자식만 존재할 경우
      3. 왼쪽,오른쪽 자식 둘 다 존재할 경우

<br>
<br>

## 힙 구현

- **배열 자료구조 활용**
- root 노드의 index 번호를 1로 지정
<br>

> <br>
> 부모 노드 index = 자식 노드 index / 2 <br>
> <br>
> 왼쪽 자식 노드 index = 부모 노드 index * 2 + 1<br>
> <br>

<img width="372" alt="image" src="https://user-images.githubusercontent.com/56334513/163349117-705543a2-be79-4a2c-8071-ea2f480f41d7.png">

<br>
<br>

## 시간 복잡도

`depth가 h`라면 n개의 노드를 가지는 heap에 데이터를 삽입 혹은 pop하면 <br>
`최악의 경우 root 노드에서 leaf 노드까지 비교`해야 하므로! <br>

### h = logN = O(logN)