## HTTP 메시지에 모든 것을 전송
+ HTML, CSS, JS
+ IMG, 음성, 영상, 파일, 텍스트
+ JSON, XML (API)
+ 서버 간에 데이터를 주고 받을 때도 대부분 HTTP

<br>

## HTTP 역사
+ `HTTP/0.9` 1991년: GET 메서드만 지원, Http 헤더 X
+ `HTTP/1.0` 1996년: 메서드, 헤더 추가
+ `HTTP/1.1` **1997년**: 가장 많이 사용.
  + 현재 RFC7230~7235(2014) 스펙이 최신.
+ `HTTP/2` 2015년: 성능 개선
+ `HTTP/3` ~: TCP 대신 UDP 사용, 성능 개선

<br>

## HTTP 기반 프로토콜

+ TCP: HTTP/1.1, HTTP/2
+ UDP: HTTP/3


<br>

## HTTP 특징

+ 클라이언트 - 서버 구조
+ 무상태 프로토콜, 비연결성
+ HTTP 메시지(요청, 응답)
+ 단순하고 확장 가능함

## 클라이언트 서버 구조
+ **Request - Response 구조**라고도 함
+ 클라이언트는 서버에게 요청을 보내고, 서버는 요청에 따른 결과를 응답함
+ 클라이언트는 보통 UI이고, 서버는 비즈니스 로직을 처리
> **비즈니스 로직** <br>
> 업무에 필요한 데이터 처리를 수행하는 응용프로그램의 일부. 데이터 조회, 수정, 삽입, 삭제 등을 수행하는 루틴. 클라이언트는 알 수 없는, 보이는 것의 그 뒤에서 일어나는 각종 처리

## 무상태 프로토콜 (Stateless Protocol)

+ 서버는 클라이언트의 상태를 보존하지 않는다.
+ 장점: 서버 확장성 good. (scale out: 수평 확장)
+ 단점: 클라이언트는 스펙에 맞춘 데이터를 모두 전송

### 스케일 아웃
<img width="452" alt="image" src="https://user-images.githubusercontent.com/56334513/171982294-c932e326-0029-4b74-9764-d390fc13a588.png">


<br>

### 그렇다면 무상태 프로토콜과 상태 프로토콜의 차이점은?

    시나리오: 노트북을 사고 싶어서 하이마트에 간 고객

**Stateful**: 중간에 다른 점원이 바뀌면 안됨
 + 만약 바뀌려면 다른 점원에게 상태 정보를 알려줘야 함
**Stateless**: 중간에 다른 점원이 바뀌어도 아무 지장 없음
 + 고객이 증가하더라도 점원만 대거 투입시키면 대응 가능
 + 그러므로 **무한한 서버 증설을 가능케 함**

### Stateless의 한계

+ 모든 것을 무상태로 설계할 수 있을까?
  + 로그인 정보같은 경우는 브라우저 쿠키나 서버 세션 등을 이용해서 상태를 유지해야 하긴 함.
  + 무상태는 로그인이 필요 없는 단순한 서비스 소개 화면을 예를 들 수 있음
+ 상태 유지를 피할 수는 없으므로 최소한만 사용
+ 갑자기 너무 많은 데이터 요청이 온다면?
  + 서버의 트래픽 과부하 -> 서버의 추가 증설 -> 비용 증가

<br>

## 비연결성 (Connectionless)

### 연결을 유지하면?
<img width="717" alt="image" src="https://user-images.githubusercontent.com/56334513/171988238-0600d47f-24c3-475c-9bc9-c9959eba419a.png">

클라이언트2와 서버가 요청과 응답을 주고 받는데, 클라이언트1은 아무것도 하지 않음에도 연결 상태를 계속 유지하고 있다.
<br>

+ HTTP는 기본이 연결을 유지하지 않는 모델이다.
+ 일반적으로 초 단위 이하의 빠른 속도로 응답
+ 웹 브라우저에서 계속 동시에 연속해서 검색 버튼을 누르는 것은 흔치 않음. 특정 시간동안 수 천명으로부터 동시에 처리하는 요청은 수십개 이하로 매우 적음
+ 서버 자원을 매우 효율적으로 사용할 수 있음.

### 한계

+ 다음 페이지로 넘어가면?
  + TCP/IP 연결을 새로 맺어야 함 (3-way-handshake 시간 추가발생)
+ 웹 브라우저로 사이트를 요청하면?
  + HTML뿐만 아니라, css, js, 이미지 등 수많은 자원을 다운로드받아야 함.
  + e.g. `연결` - `요청/HTML 응답` - `종료`, `연결` - `요청/css 응답` - `종료`

### 극복

+ 현재는 `HTTP 지속 연결`(Persistent Connection)로 문제 해결
+ HTTP/2, HTTP/3에서는 더 많은 최적화가 되어있음
+ e.g. `연결` - `요청/HTML 응답`, `요청/css 응답`, `요청/js 응답` - `종료`

<br>

> Stateless로 잘 짜여진 서버들을 증설하는게 대용량 트래픽을 대처할 수 있음

<br>

## HTTP 메시지

HTTP 메시지는 `시작 라인`, `헤더`, `메시지 바디`로 구분한다.

### start-line

### : 요청 메시지
<img width="330" alt="image" src="https://user-images.githubusercontent.com/56334513/171988605-138f53b0-555b-4489-92b8-cf3b82d393ce.png">


#### start-line: **request-line** / status-line
  + **HTTP 메서드**
    + 종류: GET, POST, PUT, PATCH, DELETE...
    + 서버가 수행할 동작을 지정하는 것. GET은 리소스를 조회함
  + **요청 대상**
    + 절대경로 + 쿼리파라미터
  + **HTTP 버전**

### : 응답 메시지

<img width="325" alt="image" src="https://user-images.githubusercontent.com/56334513/171988804-1da8b625-5116-4e50-8128-d75cf2892b6a.png">

#### start-line = **status-line**
  + HTTP 버전
  + HTTP 상태 코드
  + 이유 문구

<br>

### HTTP 헤더

+ HTTP 전송에 필요한 모든 부가정보

### HTTP 메시지 바디

+ 실제 전송할 데이터
+ HTML, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능