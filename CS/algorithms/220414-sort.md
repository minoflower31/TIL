# Bubble Sort

#### 인접한 두 개의 데이터를 비교해서 앞 데이터가 뒤 데이터보다 큰 경우 swap

<img width="463" alt="image" src="https://user-images.githubusercontent.com/56334513/163374240-3d914bcb-2317-463e-bdc7-872bb6fdc815.png">
<br>

## 특징

- n개의 원소가 있을 경우 최대 n-1번 로직 적용
  - 로직이 1번 적용 때마다 최댓값이 결정됨
- 한번도 swap이 일어나지 않으면 정렬 종료. (boolean 으로 체크)

<br>

## 시간 복잡도

- 반복문 2개 **O(n^2)**
- 완전 정렬이 돼있을 경우 **O(n)**

<br>
<br>

# Selection Sort

#### 최솟값을 찾아 swap 방식으로 앞에서부터 채워넣는 알고리즘

<br>

## 시간 복잡도

- 반복문이 2개이므로 O(n^2)
- 완전 정렬이 돼있을 경우 **O(n)**

<br>
<br>

# Insert Sort

#### index 1부터 역순으로 진행하면서 자신보다 큰 값이 있으면 swap 하는 알고리즘

<br>

## 시간 복잡도

- 반복문이 2개이므로 O(n^2)
- 완전 정렬이 돼있을 경우 **O(n)**

<br>
<br>

# `Quick Sort`

#### 기준점(pivot)을 정해서 pivot보다 작은 데이터는 좌측, pivot보다 큰 데이터는 우측으로 보내는 알고리즘
<br>

- 재귀호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지기 때문에 반드시 끝나는 것을 보장함. 
- 퀵 소트가 가장 빠른 이유
  - 사용자가 메모리에 데이터를 불러올 경우 cpu와 메모리 사이에 캐시가 존재. 합병 정렬은 임시 배열을 매번 생성하기 때문에 메모리로 건너뛰지만, 퀵 정렬은 메모리에 한번 로드하고 나머지 수행은 캐시 데이터를 이용하기 때문

<br>

- 불안정 알고리즘, 분할 정복 알고리즘
  - 원소들 중에 같은 값이 있는 경우에 같은 값을 정렬한 이후, 순서가 초기 순서와 달라질 수 있음

<br>

## 시간 복잡도

- O(NlogN) : 병합 정렬과 유사
- 최악의 경우는 O(N^2)
  - 배열의 요소가 모두 정렬돼있을 경우, pivot 하나에 대해 while문으로 n번씩 수행. 그래서 원소 n개 * 반복 n번 = O(BN^2)
  
<br>
<br>

# `Merge Sort`

#### 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음, 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘

**작동 방법** (하향식 2-way 합병 정렬) (2개의 부분리스트로 분할)
+ 리스트의 길이가 1 이하면 이미 정렬된 것
+ **분할(divide)**: 정렬되지 않은 리스트를 절반으로 나눠 비슷한 크기의 두 서브 리스트로 나눔
+ **정복(conquer)**: 각 서브 리스트를 재귀적으로 **합병(combine)**. 이 때 정렬 결과는 **임시배열에 저장됨**
+ **복사(copy)**: 임시 배열에 저장된 결과를 원래 배열에 복사

<br>

- 안정 알고리즘, 분할 정복 알고리즘
- in-place sort(평상적으로 쓰임)
- out-place sort

<br>

## 시간 복잡도

<img width="456" alt="image" src="https://user-images.githubusercontent.com/56334513/165450793-5fde1c1f-456c-4cc5-b686-147e3df0fd06.png">

- O(N)
  - 각 단계마다 하나의 노드 안의 배열의 길이는 n/2^i.
  - 각 단계에 2^i 개.
  - 둘을 곱하면 O(N)의 시간복잡도.
- O(logN)
  - 단계마다 항상 `logN` 개씩 만들어짐
- 최종: **O(NlogN)**